## 전략 패턴
- 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴.
  * 여기서는 전략은 비즈니스 규칙, 알고리즘등이 될 수 있다.
- 같은 문제를 해결하는 알고리즘이 클래스별로 캡슐화되어 있고, 이들이 필요할 때 교체/추가할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있도록 하는 디자인 
패턴이다.

### 전략 패턴 다이어그램

- Strategy: 외부에서 알고리즘을 동일한 방식으로 호출할 수 있도록 interface로 설정
- ConcreteStrategy1,2,3: 구체 알고리즘들
- Context: 알고리즘을 사용하는 주체.

<img width="722" alt="스크린샷 2020-05-24 오후 4 16 59" src="https://user-images.githubusercontent.com/26040955/82748065-ff9a7c80-9dd9-11ea-90e8-a45317505b5d.png">


## 예시 - 로봇 설계

- 아톰과 태권V 로봇을 만드는데 두 로봇은 공격 기능과 이동 기능이 있다. 아톰은 공격할 때 주먹만 사용하지만 하늘을 날 수가 있고 태권V는 미사일로 공격할 수는 있지만 
날아다니지 못하고 걷기만 할 수 있다.
- 아톰과 태권V가 로봇의 한 종류인 'is a kind of' 관계가 성립하기에 아래와 같이 상속 관계로 정의했다.

<img width="481" alt="스크린샷 2020-05-24 오후 4 33 42" src="https://user-images.githubusercontent.com/26040955/82748384-5608ba80-9ddc-11ea-8e44-a3dc697920ca.png">

- 문제 1) 기존 로봇의 공격 또는 이동 방법을 수정하려면? 
- 문제 2) 새로운 로봇을 만들어 기존의 공격 또는 이동 방법을 추가하거나 수정하려면? 
   * 문제 2에서 새로운 로봇을 추가하는 것은 자유롭게 가능하지만, 공격이나 이동 방법을 수정하거나 추가하려면 attack, move함수를 수정하게 되어 OCP를 위반한다.
   

### 문제점을 반영한 나의 첫번째 설계

- AttackStrategy와 MoveStrategy interface를 따로 파서, 각각의 전략이 수정/추가가 원활하도록 해서 OCP를 만족시키도록 했다.
- 다만, 아래와 같이 설계를 하면서 바보 같은 짓을 했는데.. 저렇게 함으로써 각 전략들이 로봇의 구체 클래스인 아톰과 태권V에 의존되기에 로봇이 추가되는 것은 만족할 수 없는 설계
이다.


<img width="1048" alt="스크린샷 2020-05-24 오후 4 57 21" src="https://user-images.githubusercontent.com/26040955/82748792-a3d2f200-9ddf-11ea-9571-2b95f6f06755.png">


### 최종 설계

- 따라서 첫번째 설계를 수정한 완성본은 다음과 같다.
- 이렇게 하면 attack 전략과 move 전략를 runtime에 자유롭게 변경/수정할 수 있고, 각 전략 class의 함수를 Robot 클래스의 함수에서 call해서 사용하면 된다.

<img width="1052" alt="스크린샷 2020-05-24 오후 5 05 07" src="https://user-images.githubusercontent.com/26040955/82748929-b8fc5080-9de0-11ea-9688-9ab92dec40d9.png">


### 참고자료

- Java 객체지향 디자인 패턴
