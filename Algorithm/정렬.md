## Bubble Sort

- 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 시간복잡도: n 제곱
- 추가 공간을 사용하지 않기에 Inplace sort
- swap을 사용하지 않기에 stable sort이다

- 예시: 7 4 5 1 3
  - 4 5 1 3 7
  - 4 1 3 5 7
  - 1 3 4 5 7
  
## Selection Sort
- 정렬되지 않은 Data들 중 가장 작은 값을 찾아 맨 앞에 두는 방식
- 시간복잡도: n 제곱
- 추가 공간을 사용하지 않기에 Inplace sort
- swap을 사용하기에 unstable sort
- 교환횟수는 상대적으로 적지만, 부분적으로 정렬되어 있어도 min값을 계속 찾아야 하기에 비효율적일 수 있다.
- 예시: 7 4 5 1 3
  - 1 4 5 7 3
  - 1 3 5 7 4
  - 1 3 4 7 5
  - 1 3 4 5 7
  
## Insertion Sort
- 손 안의 카드를 정렬하는 방법과 유사하다.
- 시간복잡도: n제곱(최악), n(최선)
- 추가 공간을 사용하지 않기에 Inplace sort
- swap을 사용하지 않기에 stable sort
- 연속적인 공간을 참조하기에 참조 지역성이 높아서 성능이 좋다.
- 비교 횟수가 bubble sort에 비해 상대적으로 적다.
- n이 50이하일때는  insertion sort를 쓰는 것이 효율적일 수 있다.
  - 50이라는 숫자는 computer system에 따라 달라질 수 있다.
  - 참조 지역성도 좋을 뿐더러 n이 작을 경우, merge나 quick sort보다 코드 복잡성이 낮고, 함수 콜이 적어서...
  
- 예시: 7 4 5 1 3
  - 4 7 5 1 3
  - 4 5 7 1 3
  - 1 4 5 7 3
  - 1 3 4 5 7

## Merge Sort
- 분할정복 알고리즘 중 하나로 하나의 배열을 두 개로 분할하여 정렬하는 방법
- 시간복잡도: nlogn
- 보통 추가적인 공간을 사용하기에 outPlace sort
  - Linked List로 하면 inplace로도 가능하지만 많이 사용하지 않는 방법이다..
- 추가적인 공간을 사용하기에 참조지역성이 떨어진다.
- stable
- 예시: 7 4 5 1 3
  - 4 7 / 5 /1 3
  - 4 5 7 / 1 3
  - 1 3 4 5 7

## Quick Sort
- 분할정복 알고리즘 중 하나로 pivot을 기준으로 양쪽으로 정렬하는 방법
- 시간복잡도: n2(최악), nlogn(평균)
- 추가 공간을 사용하지 않기에 inplace sort
- 순차적으로 공간을 참조하기에 참조지역성이 좋다.
- swap을 사용하기에 unstable sort
- 예시: 7 4 5 1 3
  - 
