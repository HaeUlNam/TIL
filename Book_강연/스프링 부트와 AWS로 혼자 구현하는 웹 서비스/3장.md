## 스프링 부트에서 JPA로 데이터베이스 다뤄보자

### MyBatis의 문제점
- 저자는 처음에 MyBatis와 같은 SQL Mapper를 이용해서 데이터베이스의 쿼리를 작성했는데, 실제로 개발하는 시간보다 SQL을 다루는 시간이 많았다. 객체 모델링보다는 테이블
 모델링에만 집중하고, 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하는 개발은 기형적이라고 느껴졌다.
- 따라서 관계형 DB를 이용하는 프로젝트에서 어떻게 객체 지향 프로그래밍을 할 수 있을지 고민이었다. 해당 해답은 JPA라는 자바 표준 ORM(Object Relational Mapping) 기술을 
통해 가능.

- MyBatis는 ORM이 아니고, SQL Mapper이다. ORM은 객체를 매핑하는 것이고, SQL Mapper는 쿼리는 매핑

### JPA 필요성
- 현대의 웹 Application에서 RDB(Oracle, MySQL)는 빠질 수 없는 요소이다. 그러다 보니 객체를 관계형 데이터베이스에서 관리하는 것이 무엇보다 중요합니다.

- 기존 문제점 1) 그러면서 현업 프로젝트는 대부분 Application code보다 SQL로 가득하게 된 것.
  * RDB가 SQL만 인식할 수 있기 때문이다. 따라서 각 테이블마다 CRUD(Create, Read, Update, Delete) SQL을 매번 생성해야 한다.
  * 아래는 User 객체를 테이블로 관리하는 예시
  ```sql
  insert into user (id, name, ...) values(...);
  select * from user where...;
  update user set ... where ...;
  delete frome user where ..;
  ```
  * 현업에는 테이블 수가 엄청 많은데, 그러면 SQL 단순 작업을 해야 한다....
  
- 기존 문제점 2) 관계형 데이터베이스와 객체 지향 프로그래밍 간의 패러다임 불일치
  * 관계형 데이터베이스: 어떻게 데이터를 저장할지 초점
  * 객체 지향 프로그래밍: 메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술
  * 위처럼 두 개의 패러다임이 다른데, 객체를 데이터베이스에 저장하려고 하니 여러 문제가 발생한다.
  * 아래는 User와 Group이 부모-자식 관계임을 알 수 있는 예시
  ```java
  //User가 본인이 속한 Group을 가져온 코드
  User user = findUser();
  Group group = user.getGroup();
  ```
  
  * 위에 데이터베이스를 추가하면 아래처럼 DAO를 통해 User, Group 따로 조회하게 된다. 이에 따라 User, Group은 어떤 관계인지 알 수 없고,
  상속, 1:N 등 다양한 객체 모델링을 데이터베이스로는 구현할 수 없습니다.
  ```java
  //DAO는 데이터베이스에 접근하기 위한 객체
  User user = userDao.findUser();
  Group group = groupDao.findGroup(user.getGroupId());
  ```

- 따라서 위의 2가지 문제점을 해결하기 위해 JPA가 꼭 필요하다. 즉, 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 
대신 생성해서 실행합니다. 더이상은 SQL에 종속적인 개발을 하지 않아도 된다. 
- 객체 중심으로 개발을 하게 되니 생산성 향상뿐만 아니라 유지 보수성도 증가한다.

### Spring Data JPA
- JPA는 인터페이스로서 자바 표준명세서입니다. 원래는 인터페이스인 JPA를 다루기 위해 구현체가 필요한데, 대표적으로 Hibernate, Eclipse Link등이 있다.
- 하지만 Spring에서는 이 구현체들을 추상화시킨 Spring Data JPA라는 모듈 사용
  * JPA <- Hibernate <- Spring Data JPA
- 사실 Hibernate와 Spring Data JPA는 큰 차이 없지만, 아래 두가지 때문에 Spring Data JPA가 나오게 되었다.

#### 구현체 교체의 용이성

- Hibernate 외에 다른 구현체로 쉽게 교체하기 위함입니다. Hibernate가 언젠간 수명을 다해서 새로운 JPA 구현체가 대세로 떠오를 때, Spring Data JPA를 
쓰는 중이라면 아주 쉽게 교체할 수 있습니다. Spring Data JPA 내부에서 구현체 매핑을 지원해주기 때문입니다.
- 실제로 자바의 Redis 클라이언트가 Jedis에서 Lettuce로 대세가 넘어갈 때 Spring Data Redis를 쓰신 분들은 아주 쉽게 교체를 했습니다.

### 저장소 교체의 용이성

- 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함
- 점점 트래픽이 많아져 관계형 데이터베이스로는 도저히 감당이 안 될 때가 올 수 있다. 이 때 Mongo DB 사용이 필요하다면 Spring Data Mongo DB로 변경만 하면 된다.
왜냐하면 Spring Data의 하위 프로젝트들은 기본적인 CRUD의 인터페이스가 같기 때문.
- 즉, Spring Data JPA/ Redis/ MongoDB 등등은 save(), findAll(), findOne() 등을 인터페이스로 갖고 있습니다. 따라서 저장소가 교체되어도 기본적인
기능은 변경할 것이 없다. 그렇기에 Hibernate를 직접 쓰기보다 Spring Data 프로젝트를 권장

## 프로젝트에 Spring Data JPA 적용하기

```build.gradle
compile('org.springframework.boot:spring-boot-starter-data-jpa')
compile('com.h2database.h2')
```

- spring-boot-starter-data-jpa: 스프링 부트용 Spring Data JPA 추상화 라이브러리
- h2  
  * 인메모리 관계형 데이터베이스
  * 별도의 설치 없이 프로젝트 의존성만으로 관리 가능
  * 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다. 따라서 테스트 용도로 많이 사용
  * 여기서는 JPA의 테스트, 로컬 환경에서의 구동에서 사용

- Domain 패키지: 도메인을 담을 패키지인데, 도메인이란 게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제 영역이라고 생각하면 된다.


```java
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Getter
@NoArgsConstructor
@Entity
public class Posts {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 500, nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT",nullable = false)
    private String content;

    private String author;

    @Builder
    public Posts(String title, String content, String author){
        this.title = title;
        this.content = content;
        this.author = author;
    }
}
```

- 여기서 Post 클래스는 DB와 매칭될 클래스인데, Entity 클래스라고도 한다. JPA를 사용하면 DB 데이터에 작업할 경우 실제 쿼리를 날리는 것이 아니라 이 Entity 클래스의 수정을 통해 작업할 수 있다. 
- @Entity는 JPA Annotation, @Getter/@NoArgsContructor는 롬복 Annotation이다.
- @Entity
  * 테이블과 링크될 클래스임을 나타냅니다.
  * 기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭합니다. (SalesManager.java -> sales_manager table)
- @Id
  * 해당 테이블의 PK 필드를 나타냅니다.
- @GeneratedValue
  * PK의 자동 생성 전략
  * 스프링 부트 2.0에서는 GenerationType.IDENTITY 옵션을 추가해야만 auto_increment가 됩니다.
- @Columnn
  * 테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 됩니다. 하지만 기본값 외에 추가로 변경이 필요한 옵션이 있을 경우
  사용하게 된다.
  * 문자열의 경우 VARCHAR(255)가 기본값인데, 사이즈를 500으로 늘리고 싶거나 타입을 TEXT(content)로 변경하고 싶거나 등의 경우에 사용됩니다.
- @NoArgsConstructor
  * 기본 생성자 자동 추가
  * public Posts(){}와 같은 효과
- @Builder
  * 해당 클래스의 빌더 패턴 클래스 생성
  * 생성자 상단에 선언하면 생성자에 포함된 필드만 빌더에 포함

- 서비스 초기 구축 단계에선 테이블 설계(여기에서는 Entity 설계)가 빈번하게 변경되는데, 이때 롬복의 어노테이션들은 코드 변경량을 최소화시켜 주기 때문에 
적극적으로 사용한다.

### Natural Key vs Artificial Key
- Natural Key: 비즈니스 모델에서 자연스럽게 나오는 키(ex) 주민등록번호)
- Artificial Key(Surrogate Key): 비즈니스 모델에서 나오는 것이 아닌 새롭게 생성한 키
- 둘 중에 Artificial Key를 Primary Key로 하는 것이 더 좋다.(라고... 단정 지을 수는 없겠다... 참고 - [PK복합키 또는 인조식별자 + 유니크 인덱스](https://okky.kr/article/257331))
  * 예시: 만약 주민등록번호를 PK로 지정했다면, 옛날에는 사이트 가입 시에 유용하게 사용되었을 것이다. 하지만 현재 관련법이 바뀌었기에 사이트 가입 시에 
  주민등록번호를 요구하지 않도록 되었다. 이렇게 비즈니스상 유니크 키가 PK로 지정되면 문제가 발생하게 된다. 따라서 Artificial Key를 PK로 하고, 주민등록 등은
  유니크 키로 별도로 추가하는 것을 추천!
- 하지만 Artificial Key는 비즈니스 상으로 의미가 없기에 DB query가 복잡해진다는 단점이 존재한다.

### 참고
- 웬만하면 Entity의 PK는 Long 타입의 Auto_increment를 추천(MYSQL 기준 bigint인데, 범위가 가장 넓은 것). 주민등록번호와 같이 비즈니스상 유니크 키나 
여러 키를 조합한 복합키로 PK를 잡을 경우 난감한 상황이 종종 발생.
  * FK를 맺을 때 다른 테이블에서 복합키 전부를 갖고 있거나, 중간 테이블을 하나 더 둬야 하는 상황이 발생합니다.
  * 인덱스에 좋은 영향을 끼치지 못합니다.
  * 유니크한 조건이 변경될 경우 PK 전체를 수정해야 하는 일이 발생.
- 따라서 주민등록번호, 복합키 등은 유니크 키로 별도로 추가하시는 것을 추천드립니다.

### Entity 클래스에서는 절대 Setter 메소드를 만들지 않는다.

- 무작정 getter/setter를 생성하염 해당 클래스의 인스턴스 값들이 언제 어디서 변해야 하는지 코드상으로 명확하게 구분할 수 없어, 차후 기능 변경 시 정말 복잡해짐
- 그래서 Entity 클래스에서는 무작정 Setter 메소드를 만들지 않고, 그 목적과 의도를 나타낼 수 있는 메소드를 추가해야만 한다.

- 잘못된 사용 예
```java
public class Order{
  public void setStatus(boolean status){
    this.status = status;
  }
}

public void 주문서비스의 취소이벤트(){
 order.setStatus(false);
}
```

- 올바른 사용 예
```java
public class Order{
  public void cancelOrder(boolean status){
    this.status = status;
  }
}

public void 주문서비스의 취소이벤트(){
 order.cancelOrder(false);
}
```
- 그럼 setter가 없는 상황에서 어떻게 값을 채워 DB에 삽입해야 할까요?
  * 기본적인 구조는 생성자를 통해 최종값을 채운 후 DB에 삽입하는 것이며, 값 변경이 필요한 경우 해당 이벤트에 맞는 public 메소드를 호출하여 변경하는 것을 전제한다. 이 책에서는 생성자 대신에 @Builder를 통해 제공되는 빌더 클래스를 사용한다. 
  * @Builder를 사용하는 이유: Builder 클래스를 사용하면 아래와 같이 어느 필드에 어떤 값을 채워야할지 명확하게 인지할 수 있기 때문입니다.
  ```java
  Example.builder()
  .a(a)
  .b(b)
  .build();
  ```

- 이제 생성하는 PostsRepository 인터페이스는 Posts 클래스로 Database를 접근하게 해줄 JpaRepository입니다.
  * 보통 ibatis나 MyBatis 등에서 Dao라고 불리는 DB Layer 접근자입니다.
  * JPA에선 Repository라고 부르며 인터페이스로 생성합니다.
  * 단순히 인터페이스를 생성 후, JpaRepository<Entity 클래스, PK 타입>를 상속하면 기본적인 CRUD 메소드가 자동으로 생성됩니다.
  * @Repository를 추가할 필요도 없다.
  * 주의할 점은 Entity 클래스와 기본 Entity Repository는 함께 위치해야 한다. 둘은 아주 밀접한 관계이고, Entity 클래스는 기본 Repository 없이는 제대로 역할을 할 수가 없습니다.
  * 나중에 프로젝트 규모가 커져 도메인별로 프로젝트를 분리해야 한다면 이때 Entity 클래스와 기본 Repository는 함께 움직여야 하므로 도메인 패키지에서 함께 관리합니다.

### Spring Data JPA 테스트 코드



### 참고자료
- [코딩스타일](https://namu.wiki/w/%EC%BD%94%EB%94%A9%20%EC%8A%A4%ED%83%80%EC%9D%BC)
- [Spring Data JPA 기본키 매핑하는 방법](https://ithub.tistory.com/24)
- [TEXT와 VARCHAR 데이터 타입](https://ra2kstar.tistory.com/82)
- [기본키는 무엇으로 할까 - 자연키, 인조키](https://multifrontgarden.tistory.com/180)
- [Primary Key - Surrogate Key VS Natural Key](https://rampart81.github.io/post/surrogate_key_vs_natural_key/)
- [Concepts of dimensional data modeling](https://www.ibm.com/support/knowledgecenter/en/SSGU8G_12.1.0/com.ibm.whse.doc/ids_ddi_350.htm)
- [MySQL, 데이터형과 범위](https://m.blog.naver.com/PostView.nhn?blogId=dudwo567890&logNo=220847437396&proxyReferer=https:%2F%2Fwww.google.com%2F)
