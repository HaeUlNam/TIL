
## 람다식(Lambda expression)

- 자바8(JDK1.8)에서부터 도입되었다.


### 람다식이란?
- 람다식은 간단히 말해서 메서드를 하나의 식으로 표현한 것. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명함수'라고도 한다.
```java
int[] arr= new int[5];
Arrays.setAll(arr, (i)-> (int)(Math.random()*5)+1);

////////////////////////////////////////////////////
int method(){
   return (int) Math.random()*5 + 1;
}
```

### 람다식 작성하기
- 람다식은 '익명 함수'답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{}사이에 '->'를 추가한다.

```java
int max(int a, int b){
  return a > b ? a : b;
}

/* 람다식으로 변환 */
(int a, int b) -> {
    return a > b ? a : b;
}

/* return문 대신 '식'으로 대신 할 수 있다 */
/* 이렇게 하면 식의 연산결과가 자동적으로 반환값이 된다. */

(int a, int b) -> a > b ? a : b

/* 대부분 매개변수 타입 생략 가능 */

(a, b) -> a > b ? a : b

/* 매개변수가 하나뿐인 경우 괄호 생략 가능 */
a -> a * a

/* 매개변수의 타입이 있다면 괄호 생략 불가 */
(int a) -> a * a
```

### 함수형 인터페이스(Functional Interface)
- 람다식을 다루기 위한 interface를 functional interface라고 부르고, 아래와 같이 오직 하나의 추상 메서드만 정의되어야 한다.
  * @FunctionalInterface를 아래와 같이 붙이면 컴파일러가 함수형 인터페이스를 올바르게 정의했는지 확인해주기에 꼭 붙이는 것이 좋다.
```java
@FunctionalInterface
interface MyFunction{
    public abstract int max(int a, int b);
}
```

- 기존에는 아래와 같이 인터페이스의 메서드 하나를 구현하는데도 복잡하게 했어야 했는데,
```java
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");  //ArrayList 반환

Collections.sort(list, new Comparator<String>(){
    public int compare(String s1, String s2){
        return s2.compareTo(s1);
    });
}
```
- 아래처럼 간단히 처리할 수 있게 되었다.

```java
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");

Collections.sort(list, (s1, s2) -> s2.compareTo(s1));  //내림차순
```

#### 함수형 인터페이스 타입의 매개변수와 반환타입

```java
@FunctionalInterface
interface MyFunction{
   void myMethod();        //추상메서드
}
```
- 메서드의 매개변수가 MyFunction 타입이면, 이 메서드를 호출할 때 아래와 같이 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻

```java
void aMethod(MyFuntion f){
   f.myMethod();
}
...
MyFunction f = () -> System.out.println("myMethod()");
aMethod(f);
```

- 또는 참조변수 없이 바로 넘겨주는 것도 가능하다.
```java
aMethod(() -> System.out.println("myMethod()"));
```

- 반환형이어도 가능
```java
MyFunction myMethod(){
   return () -> {};
}
```

- 람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 즉, 변수처럼 메서드를 주고 받는 것이 가능해진 것. 사실상 메서드가 아니라 객체를 주고받는 것이라 근본적으로 달라진 것은 아무것도 없지만, 람다식 덕분에 예전보다 코드가 더 간결하고 이해하기 쉬워졌다.

```java
//람다식 예제
@FunctionalInterface
interface MyFunction{
    void run();
}

public class helloworld {
    static void execute(MyFunction f){
        f.run();
    }

    static MyFunction getMyFunction(){
        MyFunction f = () -> System.out.println("f3. run()");
        return f;
    }

    public static void main(String[] args) {
        MyFunction f1 = () -> System.out.println("f1. run()");

        MyFunction f2 = new MyFunction() {
            @Override
            public void run() { //외부에서 실행하려면 public으로 해야 한다.
                System.out.println("f2. run()");
            }
        };

        MyFunction f3 = getMyFunction();

        f1.run();
        f2.run();
        f3.run();

        execute(f1);
        execute( () -> System.out.println("run ()"));
    }
}
```

#### 람다식의 타입과 형변환
- 함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. 람다식은 익명 객체이고 익명 객체는 타입이 없다. 정확히 말하면 타입은 있지만 컴파일러가 임의로 이름을 정하기 때문에 알 수 없다. 그래서 아래와 같이 형변환이 필요. 다만, 아래의 경우는 형변환 생략가능.
```java
MyFunction f = (MyFunction)(()->{});
```

- 람다식은 이름이 없을 뿐 분명히 객체인데도, 아래와 같이 Object 타입으로 형변환 할 수 없다. 람다식은 <b>오직 함수형 인터페이스</b>로만 형변환이 가능하다.
```java
Object obj = (Object)(()->{}); //에러. 함수형 인터페이스로만 형변환 가능
```

- 굳이 Object 타입으로 변경하려면, 먼저 함수형 인터페이스로 변환하고 진행해야 한다.

```java
Object obj = (Object)(MyFunction)(()->{}); //Object 생략 가능
String str = ((Object)(MyFunction)(()->{})).toString(); //Object 생략하면 에러 발생
```

#### 외부 변수를 참조하는 람다식

- 람다식도 익명 객체, 즉 익명 클래스의 인스턴스이므로 람다식에서 외부에 선언된 변수에 접근하는 규칙은 익명 클래스와 동일하다.
   * 람다식 내에서 참조하는 지역변수는 final이 붙지 않았더라도 상수로 간주된다. 즉 아래에서 지역변수 i와 val이 이것에 포함되는데, Outer의 val과 Inner의 val은 상수로 간주되지 않으므로 값을 변경해도 된다.

```java
@FunctionalInterface
interface MyFunction{
    void myMethod();
}

class Outer{
    int val = 10; //Outer.this.val

    class Inner {
        int val = 20; //this.val

        void method(int i){
            int val = 30; // final int val = 30;
            //i = 10; //에러..

            MyFunction function = ()->{
                System.out.println("i: " + i);
                System.out.println("val: " + val);
                System.out.println("this.val: " + this.val);
                System.out.println("outer.this.val: " + Outer.this.val);
            };

            function.myMethod();
        }
    }
}

public class helloworld {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.method(100);
    }
}
```

- 외부 지역변수와 같은 이름의 람다식 매개변수는 허용되지 않는다.

### java.util.function 패키지




















































### 참고자료
- [내부 클래스(inner class)](https://shrtorznzl.tistory.com/23)
